# -*- coding: utf-8 -*-
"""Librería Final - Tomás Hick

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NxlsC8F82TJx6op7mUcYSL5UAqxD0V5J
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from scipy.stats import norm
import statsmodels.api as sm
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from statsmodels.formula.api import ols
from statsmodels.stats.anova import anova_lm

class ResumenNumerico:
    def __init__(self, datos):
        """
        Inicializa la clase con un conjunto de datos.

        Args:
        - datos (array-like): Los datos sobre los cuales se realizarán los cálculos.
        """
        self.datos = np.array(datos)

    def calculo_de_media(self):
        """
        Calcula la media de los datos.

        Returns:
        - float: La media de los datos.
        """
        return np.mean(self.datos)

    def calculo_de_mediana(self):
        """
        Calcula la mediana de los datos.

        Returns:
        - float: La mediana de los datos.
        """
        return np.median(self.datos)

    def calculo_de_desvio_estandar(self):
        """
        Calcula el desvío estándar de los datos.

        Returns:
        - float: El desvío estándar de los datos.
        """
        return np.std(self.datos)

    def calculo_de_cuartiles(self):
        """
        Calcula los cuartiles Q1, Q2 (mediana) y Q3 de los datos.

        Returns:
        - list: Una lista con los valores de Q1, Q2 y Q3.
        """
        q1 = np.percentile(self.datos, 25)
        q2 = np.percentile(self.datos, 50)
        q3 = np.percentile(self.datos, 75)
        return [q1, q2, q3]

    def generacion_resumen_numerico(self):
        """
        Genera un resumen numérico completo de los datos, incluyendo media, mediana,
        desvío estándar, cuartiles, mínimo y máximo.

        Returns:
        - dict: Un diccionario con las estadísticas calculadas.
        """
        res_num = {
            'Media': self.calculo_de_media(),
            'Mediana': self.calculo_de_mediana(),
            'Desvio': self.calculo_de_desvio_estandar(),
            'Cuartiles': self.calculo_de_cuartiles(),
            'Mínimo': min(self.datos),
            'Máximo': max(self.datos)
        }
        return res_num

    def muestra_resumen(self):
        """
        Muestra por consola un resumen numérico de los datos.

        """
        resumen = self.generacion_resumen_numerico()
        print("Resumen Numérico:")
        for estadistica, valor in resumen.items():
            print(f"{estadistica}: {valor}")

# Ejemplo de uso:
# datos = [1, 2, 3, 4, 5]
# resumen_datos = ResumenNumerico(datos)
# resumen_datos.muestra_resumen()


import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import probplot

class ResumenGrafico:
    def __init__(self, datos):
        """
        Inicializa la clase con un conjunto de datos.

        Args:
        - datos (array-like): Los datos sobre los cuales se realizarán los cálculos.
        """
        self.datos = datos

    def evalua_histograma(self, h, x):
        """
        Calcula una estimación del histograma de los datos.

        Args:
        - h (float): Ancho del intervalo del histograma.
        - x (array-like): Valores para los cuales se calculará el histograma.

        Returns:
        - list: Lista de frecuencias relativas estimadas.
        """
        min_valor = min(self.datos)
        max_valor = max(self.datos)
        intervalos = np.arange(min_valor, max_valor + h, h)

        estim_hist = []
        for punto in x:
            for i in range(len(intervalos) - 1):
                if intervalos[i] <= punto < intervalos[i+1]:
                    frec_relativa = np.sum((intervalos[i] <= self.datos) & (self.datos < intervalos[i+1])) / len(self.datos)
                    estim_hist.append(frec_relativa / h)
                    break

        return estim_hist

    def densidad_nucleo(self, h, kernel, x):
        """
        Calcula la estimación de densidad de kernel para los datos.

        Args:
        - h (float): Ancho del kernel.
        - kernel (str): Tipo de kernel ('uniforme', 'gaussiano', 'cuadratico', 'triangular').
        - x (array-like): Valores para los cuales se calculará la densidad.

        Returns:
        - array-like: Densidad estimada para los valores dados.
        """
        n = len(self.datos)
        density = np.zeros_like(x, dtype=float)

        for dato in self.datos:
            if kernel == 'uniforme':
                kernel_value = self.kernel_uniforme((x - dato) / h)
            elif kernel == 'gaussiano':
                kernel_value = self.kernel_gaussiano((x - dato) / h)
            elif kernel == 'cuadratico':
                kernel_value = self.kernel_cuadratico((x - dato) / h)
            elif kernel == 'triangular':
                kernel_value = self.kernel_triangular((x - dato) / h)
            else:
                raise ValueError("Tipo de kernel no válido")

            density += kernel_value

        density /= (n * h)

        return density

    def kernel_uniforme(self, u):
        """
        Calcula el valor del kernel uniforme.

        Args:
        - u (array-like): Valores normalizados para evaluar el kernel.

        Returns:
        - array-like: Valores del kernel uniforme evaluados en u.
        """
        return 0.5 * ((u >= -1) & (u <= 1))

    def kernel_gaussiano(self, u):
        """
        Calcula el valor del kernel gaussiano.

        Args:
        - u (array-like): Valores normalizados para evaluar el kernel.

        Returns:
        - array-like: Valores del kernel gaussiano evaluados en u.
        """
        return 1 / (np.sqrt(2 * np.pi)) * np.exp(-0.5 * u**2)

    def kernel_cuadratico(self, u):
        """
        Calcula el valor del kernel cuadrático.

        Args:
        - u (array-like): Valores normalizados para evaluar el kernel.

        Returns:
        - array-like: Valores del kernel cuadrático evaluados en u.
        """
        return 0.75 * (1 - u**2) * ((u >= -1) & (u <= 1))

    def kernel_triangular(self, u):
        """
        Calcula el valor del kernel triangular.

        Args:
        - u (array-like): Valores normalizados para evaluar el kernel.

        Returns:
        - array-like: Valores del kernel triangular evaluados en u.
        """
        return (1 - np.abs(u)) * ((u >= -1) & (u <= 1))

    def qq_plot(self):
        """
        Genera un gráfico QQ (quantile-quantile plot) de los datos.

        """
        fig, ax = plt.subplots(figsize=(8, 8))
        probplot(self.datos, plot=ax)
        ax.get_lines()[1].set_linestyle('--')  # línea de referencia
        ax.set_title('QQ Plot de los Datos')
        ax.set_xlabel('Cuantiles Teóricos')
        ax.set_ylabel('Cuantiles de los Datos')
        plt.grid(True)
        plt.show()

# Ejemplo de uso:
# datos = np.random.normal(0, 1, 100)
# resumen_grafico = ResumenGrafico(datos)
# resumen_grafico.qq_plot()



import numpy as np
from scipy.stats import norm

class GeneradoraDeDatos:
    def __init__(self, n):
        """
        Inicializa la clase con un número específico de datos a generar.

        Args:
        - n (int): Número de datos a generar.
        """
        self.n = n

    def generar_datos_dist_norm(self, media, desvio):
        """
        Genera datos distribuidos normalmente.

        Args:
        - media (float): Media de la distribución normal.
        - desvio (float): Desvío estándar de la distribución normal.

        Returns:
        - array-like: Datos generados según la distribución normal especificada.
        """
        return np.random.normal(media, desvio, self.n)

    def pdf_norm(self, x, media, desvio):
        """
        Calcula la función de densidad de probabilidad (PDF) de una distribución normal.

        Args:
        - x (array-like): Valores para los cuales se calculará el PDF.
        - media (float): Media de la distribución normal.
        - desvio (float): Desvío estándar de la distribución normal.

        Returns:
        - array-like: Valores de la PDF para los valores dados.
        """
        return norm.pdf(x, media, desvio)

    def generar_datos_dist_bs(self):
        """
        Genera datos según la distribución de Brownian Bridge.

        Returns:
        - array-like: Datos generados según la distribución de Brownian Bridge.
        """
        u = np.random.uniform(size=(self.n,))
        y = u.copy()
        ind = np.where(u > 0.5)[0]
        y[ind] = np.random.normal(0, 1, size=len(ind))
        for j in range(5):
            ind = np.where((u > j * 0.1) & (u <= (j+1) * 0.1))[0]
            y[ind] = np.random.normal(j/2 - 1, 1/10, size=len(ind))
        return y

    def pdf_bs(self, x):
        """
        Calcula la función de densidad de probabilidad (PDF) de la distribución de Brownian Bridge.

        Args:
        - x (array-like): Valores para los cuales se calculará la PDF.

        Returns:
        - array-like: Valores de la PDF para los valores dados.
        """
        phi_0 = 0.5 * norm.pdf(x, loc=0, scale=1)
        phi_sum = 0
        for j in range(5):
            mu = j / 2 - 1
            sigma = 1 / 10
            phi_sum += norm.pdf(x, loc=mu, scale=sigma)
        phi_sum *= 1 / 10
        return phi_0 + phi_sum

# Ejemplo de uso:
# generador = GeneradoraDeDatos(100)
# datos_normales = generador.generar_datos_dist_norm(0, 1)
# datos_bs = generador.generar_datos_dist_bs()



import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
from scipy import stats

class RegresionLinealSimple:
    def __init__(self, x=None, y=None):
        """
        Inicializa la clase para realizar regresión lineal simple.

        Args:
        - x (array-like): Datos de la variable independiente.
        - y (array-like): Datos de la variable dependiente.
        """
        self.x = x
        self.y = y
        self.model = None

        if x is not None and y is not None:
            self.estimar_modelo()

    def estimar_modelo(self):
        """
        Estima el modelo de regresión lineal simple.

        Raises:
        - ValueError: Si los datos de x o y no han sido proporcionados.
        """
        if self.x is None or self.y is None:
            raise ValueError("Los datos de x y y deben ser proporcionados.")

        # Añadir intercepto a los datos
        X = sm.add_constant(self.x)

        # Estimar el modelo de regresión lineal
        self.model = sm.OLS(self.y, X).fit()

    def obtener_coeficientes(self):
        """
        Obtiene los coeficientes estimados del modelo de regresión.

        Returns:
        - tuple: Coeficiente beta0 (intercepto) y beta1 (pendiente).

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("Primero debes ajustar el modelo.")

        return self.model.params[0], self.model.params[1]

    def grafica(self):
        """
        Grafica los datos de dispersión y la recta de regresión ajustada.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("Primero debes ajustar el modelo.")

        # Graficar los datos y la recta ajustada
        plt.scatter(self.x, self.y, label="Datos")
        plt.plot(self.x, self.model.predict(sm.add_constant(self.x)), label="Recta ajustada", color="red")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.title("Regresión Lineal Simple")
        plt.legend()
        plt.show()

    def qq_plot(self):
        """
        Grafica el QQ Plot de los residuos del modelo de regresión.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("Primero debes ajustar el modelo.")

        # Graficar QQ Plot de los residuos
        sm.qqplot(self.model.resid, line='s')
        plt.title('QQ Plot de los Residuos')
        plt.xlabel('Cuantiles teóricos')
        plt.ylabel('Cuantiles de los residuos')
        plt.show()

    def residuos_vs_ajustados(self):
        """
        Grafica los residuos versus los valores ajustados del modelo de regresión.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("Primero debes ajustar el modelo.")

        # Graficar Residuos vs Valores Ajustados
        plt.scatter(self.model.fittedvalues, self.model.resid)
        plt.axhline(y=0, color='r', linestyle='--')
        plt.title('Residuos vs Valores Ajustados')
        plt.xlabel('Valores Ajustados')
        plt.ylabel('Residuos')
        plt.show()

    def calcular_tobs(self):
        """
        Calcula el valor de tobs para el coeficiente beta1.

        Returns:
        - float: Valor de tobs para el coeficiente beta1.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("Primero debes ajustar el modelo.")

        # Obtener el valor de tobs para beta1
        tobs = self.model.tvalues[1]

        return tobs

    def definir_region_rechazo(self, alpha):
        """
        Define la región de rechazo para la prueba de significancia de beta1.

        Args:
        - alpha (float): Nivel de significancia para la prueba.

        Returns:
        - str: Resultado de la prueba de hipótesis ("Rechazar H0" o "No rechazar H0").

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("Primero debes ajustar el modelo.")

        # Calcular el valor crítico
        df = self.model.df_resid
        t_critico = stats.t.ppf(1 - alpha / 2, df)

        # Definir la región de rechazo
        tobs = self.calcular_tobs()
        if abs(tobs) > t_critico:
            region_rechazo = "Rechazar H0"
        else:
            region_rechazo = "No rechazar H0"

        return region_rechazo

    def intervalo_confianza_beta0(self, alpha=0.05):
        """
        Calcula el intervalo de confianza para el coeficiente beta0.

        Args:
        - alpha (float): Nivel de confianza deseado (por defecto 0.05).

        Returns:
        - tuple: Intervalo de confianza para beta0.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("El modelo no ha sido ajustado. Estime los coeficientes primero.")

        return self.model.conf_int(alpha=alpha)[0]

    def intervalo_confianza_beta1(self, alpha=0.05):
        """
        Calcula el intervalo de confianza para el coeficiente beta1.

        Args:
        - alpha (float): Nivel de confianza deseado (por defecto 0.05).

        Returns:
        - tuple: Intervalo de confianza para beta1.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is None:
            raise ValueError("El modelo no ha sido ajustado. Estime los coeficientes primero.")

        return self.model.conf_int(alpha=alpha)[1]



import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm

class RegresionLinealMultiple:
    def __init__(self, X, y):
        """
        Inicializa la clase para realizar regresión lineal múltiple.

        Args:
        - X (array-like): Matriz de variables predictoras.
        - y (array-like): Vector de variable respuesta.
        """
        self.X = X
        self.y = y
        self.model = None

    def ajustar_modelo(self):
        """
        Ajusta el modelo de regresión lineal múltiple.

        Añade un intercepto a los datos y estima el modelo OLS.

        Raises:
        - ValueError: Si los datos de X o y no han sido proporcionados.
        """
        X = sm.add_constant(self.X)  # Añadir intercepto
        self.model = sm.OLS(self.y, X).fit()

    def graficar_dispersion_recta_ajuste(self):
        """
        Grafica la dispersión de los datos y las rectas de ajuste para cada variable predictora.

        Si hay más de una variable predictora, ajusta el modelo y grafica.
        """
        if self.X.shape[1] > 1:
            # Ajustar el modelo si hay más de una variable predictora
            self.ajustar_modelo()

            # Gráfico de dispersión y rectas de ajuste
            fig, ax = plt.subplots(1, len(self.X.columns), figsize=(12, 4))
            for i, col in enumerate(self.X.columns):
                ax[i].scatter(self.X[col], self.y, label=col)
                ax[i].plot(self.X[col], self.model.predict(), color='red')
                ax[i].set_xlabel(col)
                ax[i].set_ylabel('Variable respuesta')
                ax[i].set_title(f'Dispersión de puntos - {col}')
                ax[i].legend()

            fig.tight_layout()
            plt.show()
        else:
            print("Se requieren al menos dos variables predictoras para graficar.")

    def coeficientes(self):
        """
        Retorna los coeficientes estimados del modelo.

        Returns:
        - array: Coeficientes estimados del modelo.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is not None:
            return self.model.params
        else:
            return None

    def analisis_residuos(self):
        """
        Realiza el análisis de residuos del modelo de regresión lineal múltiple.

        Grafica el QQ Plot de los residuos y el gráfico de residuos vs valores predichos.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is not None:
            residuos = self.model.resid

            # Graficar QQ Plot de los residuos
            sm.qqplot(residuos, line='s')
            plt.title('QQ Plot de los residuos')
            plt.show()

            # Graficar residuos vs valores predichos
            plt.scatter(self.model.fittedvalues, residuos)
            plt.xlabel('Valores predichos')
            plt.ylabel('Residuos')
            plt.title('Residuos vs Valores predichos')
            plt.axhline(y=0, color='r', linestyle='-')
            plt.show()
        else:
            print("Primero ajusta el modelo para analizar los residuos.")

    def almacenar_valores(self):
        """
        Almacena diferentes valores del modelo de regresión lineal múltiple.

        Returns:
        - tuple: Coeficientes, errores estándar, t-observados, y p-valores.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is not None:
            betas = self.model.params
            errores_std = self.model.bse
            t_obs = self.model.tvalues
            p_valor = self.model.pvalues
            return betas, errores_std, t_obs, p_valor
        else:
            return None

    def predecir_valores(self, X_new):
        """
        Realiza predicciones utilizando el modelo de regresión lineal múltiple.

        Args:
        - X_new (array-like): Nuevos datos de variables predictoras.

        Returns:
        - array: Valores predichos para los datos nuevos.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is not None:
            X_new = sm.add_constant(X_new)
            return self.model.predict(X_new)
        else:
            return None

    def intervalos_confianza_prediccion(self):
        """
        Calcula los intervalos de confianza para las predicciones del modelo.

        Returns:
        - DataFrame: Tabla con los intervalos de confianza de las predicciones.

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is not None:
            return self.model.get_prediction().summary_frame()
        else:
            return None

    def coeficiente_determinacion(self):
        """
        Calcula el coeficiente de determinación (R^2) del modelo.

        Returns:
        - float: Coeficiente de determinación (R^2).
        - float: Coeficiente de determinación ajustado (R^2 ajustado).

        Raises:
        - ValueError: Si el modelo no ha sido ajustado.
        """
        if self.model is not None:
            r2 = self.model.rsquared
            r2_adj = self.model.rsquared_adj
            return r2, r2_adj
        else:
            return None



import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
import statsmodels.api as sm

class RegresionLogistica:
    """
    Implementación de regresión logística utilizando statsmodels para ajustar y evaluar el modelo.

    Atributos:
        X : array-like
            Variables predictoras.
        y : array-like
            Variable objetivo.
        X_train, X_test, y_train, y_test : array-like
            Conjuntos de datos divididos en entrenamiento y prueba.
        resultados : statsmodels.genmod.generalized_linear_model.GLMResultsWrapper
            Resultados del modelo de regresión logística ajustado.
    """

    def __init__(self, X, y):
        """
        Inicializa la clase con los datos de entrada.

        Parámetros:
            X : array-like
                Variables predictoras.
            y : array-like
                Variable objetivo.
        """
        self.X = X
        self.y = y
        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    def ajustar_modelo(self):
        """
        Ajusta el modelo de regresión logística a los datos de entrenamiento.
        """
        self.X_train_sm = sm.add_constant(self.X_train)
        self.modelo = sm.Logit(self.y_train, self.X_train_sm)
        self.resultados = self.modelo.fit()

    def resumen_modelo(self):
        """
        Imprime un resumen del modelo ajustado.
        """
        print(self.resultados.summary())

    def predecir(self, X_nuevos):
        """
        Realiza predicciones sobre nuevos datos.

        Parámetros:
            X_nuevos : array-like
                Nuevos datos para realizar las predicciones.

        Retorna:
            array-like
                Predicciones del modelo.
        """
        X_nuevos_sm = sm.add_constant(X_nuevos)
        return self.resultados.predict(X_nuevos_sm)

    def matriz_confusion(self):
        """
        Calcula y devuelve una representación en cadena de la matriz de confusión.

        Retorna:
            str
                Representación de la matriz de confusión en formato de cadena.
        """
        X_test_sm = sm.add_constant(self.X_test)
        y_pred = self.resultados.predict(X_test_sm)
        y_pred_binary = (y_pred > 0.5).astype(int)
        cm = confusion_matrix(self.y_test, y_pred_binary)

        matriz_confusion_str = f"          y_test=1  y_test=0\n"
        matriz_confusion_str += f"y_pred=1        {cm[1, 1]}         {cm[1, 0]}\n"
        matriz_confusion_str += f"y_pred=0        {cm[0, 1]}         {cm[0, 0]}"

        return matriz_confusion_str

    def error_clasificacion(self):
        """
        Calcula el error de clasificación del modelo.

        Retorna:
            float
                Error de clasificación.
        """
        X_test_sm = sm.add_constant(self.X_test)
        y_pred = self.resultados.predict(X_test_sm)
        y_pred_binary = (y_pred > 0.5).astype(int)
        error = np.mean(self.y_test != y_pred_binary)
        return error




import numpy as np
from scipy import stats

class TestChiCuadrado:
    """
    Clase para realizar pruebas de chi cuadrado y calcular valores p.

    Atributos:
        observed : array-like
            Valores observados para la prueba de chi cuadrado.
        expected : array-like, opcional
            Valores esperados para la prueba de chi cuadrado. Si no se proporciona,
            se asume una distribución uniforme basada en los valores observados.
    """

    def __init__(self, observed, expected=None):
        """
        Inicializa la clase con los datos observados y esperados.

        Parámetros:
            observed : array-like
                Valores observados para la prueba de chi cuadrado.
            expected : array-like, opcional
                Valores esperados para la prueba de chi cuadrado. Por defecto, None.
        """
        self.observed = observed
        self.expected = expected

    def prueba_chi_cuadrado(self, valor_observado=None):
        """
        Realiza la prueba de chi cuadrado y calcula el valor p.

        Parámetros:
            valor_observado : float, opcional
                Valor observado de chi cuadrado. Si se proporciona, se calcula el valor p para este valor.

        Retorna:
            valor_observado : float
                Valor observado de chi cuadrado.
            p_valor : float
                Valor p obtenido de la prueba de chi cuadrado.
            df : int
                Grados de libertad de la prueba.
        """
        if self.expected is None:
            # Si no se proporciona una distribución esperada, asumimos distribución uniforme
            expected = np.full_like(self.observed, np.mean(self.observed))
        else:
            expected = self.expected

        # Calcular los grados de libertad
        df = len(self.observed) - 1

        # Calcular el valor p usando la distribución chi cuadrado
        if valor_observado is not None:
            p_valor = 1 - stats.chi2.cdf(valor_observado, df=df)
        else:
            # Realizar la prueba de chi cuadrado
            chi2, _ = stats.chisquare(f_obs=self.observed, f_exp=expected)
            p_valor = 1 - stats.chi2.cdf(chi2, df=df)
            valor_observado = chi2

        return valor_observado, p_valor, df




import pandas as pd
import numpy as np
from statsmodels.formula.api import ols
from statsmodels.stats.anova import anova_lm
from scipy import stats

class Anova:
    """
    Clase para realizar análisis de varianza (ANOVA) utilizando statsmodels.

    Atributos:
        dataframe : pd.DataFrame
            DataFrame que contiene los datos para el ANOVA.
        formula : str
            Fórmula para el modelo ANOVA en formato de fórmula de statsmodels.
        modelo : statsmodels.regression.linear_model.RegressionResultsWrapper, opcional
            Modelo ajustado utilizando statsmodels.
        resultados_anova : pd.DataFrame, opcional
            Resultados del ANOVA en formato de DataFrame.
        grupos : array-like, opcional
            Grupos únicos en los datos del DataFrame.

    Métodos:
        __init__(self, dataframe, formula)
            Inicializa el Analizador ANOVA con un DataFrame y una fórmula para el modelo.
        ajustar(self)
            Ajusta el modelo ANOVA utilizando la fórmula especificada y los datos del DataFrame.
        resumen(self)
            Imprime un resumen del modelo ANOVA ajustado.
        tabla_anova(self)
            Devuelve la tabla ANOVA como un DataFrame de pandas.
        intervalos_confianza(self, alpha=0.05)
            Calcula los intervalos de confianza para las diferencias de medias entre los grupos.
        diferencias_medias(self)
            Calcula las diferencias de medias entre los grupos.
    """

    def __init__(self, dataframe, formula):
        """
        Inicializa el Analizador ANOVA con un DataFrame y una fórmula para el modelo.

        Parámetros:
            dataframe (pd.DataFrame): DataFrame que contiene los datos.
            formula (str): Fórmula para el modelo ANOVA en formato de fórmula de statsmodels.
        """
        self.dataframe = dataframe
        self.formula = formula
        self.modelo = None
        self.resultados_anova = None
        self.grupos = None

    def ajustar(self):
        """
        Ajusta el modelo ANOVA utilizando la fórmula especificada y los datos del DataFrame.
        """
        self.modelo = ols(self.formula, data=self.dataframe).fit()
        self.resultados_anova = anova_lm(self.modelo)
        self.grupos = self.dataframe[self.modelo.endog_names].unique()

    def resumen(self):
        """
        Imprime un resumen del modelo ANOVA ajustado.
        """
        if self.modelo is None:
            print("¡Primero ajusta el modelo utilizando el método ajustar()!")
        else:
            print(self.modelo.summary())

    def tabla_anova(self):
        """
        Devuelve la tabla ANOVA como un DataFrame de pandas.
        """
        if self.resultados_anova is None:
            self.ajustar()
        return self.resultados_anova

    def intervalos_confianza(self, alpha=0.05):
        """
        Calcula los intervalos de confianza para las diferencias de medias entre los grupos.

        Parámetros:
            alpha (float): Nivel de significancia para el intervalo de confianza. Por defecto, alpha=0.05 (95% de confianza).

        Retorna:
            dict: Diccionario con los intervalos de confianza para las diferencias de medias entre los grupos.
        """
        if self.grupos is None:
            self.ajustar()

        # Calcular la media general
        media_general = self.dataframe[self.modelo.endog_names].mean()

        # Calcular los intervalos de confianza para las diferencias de medias
        intervalos_confianza = {}
        for grupo in self.grupos:
            datos_grupo = self.dataframe[self.dataframe[self.modelo.endog_names] == grupo]
            media_grupo = datos_grupo[self.modelo.endog_names].mean()
            n_grupo = len(datos_grupo)
            se_grupo = np.sqrt(self.modelo.scale / n_grupo)
            t_critico = stats.t.ppf(1 - alpha / 2, self.resultados_anova['df']['Residual'])
            margen_error = t_critico * se_grupo
            limite_inferior = media_grupo - media_general - margen_error
            limite_superior = media_grupo - media_general + margen_error
            intervalos_confianza[grupo] = (limite_inferior, limite_superior)

        return intervalos_confianza

    def diferencias_medias(self):
        """
        Calcula las diferencias de medias entre los grupos.

        Retorna:
            dict: Diccionario con las diferencias de medias entre los grupos.
        """
        if self.grupos is None:
            self.ajustar()

        diferencias_medias = {}
        for grupo in self.grupos:
            datos_grupo = self.dataframe[self.dataframe[self.modelo.endog_names] == grupo]
            media_grupo = datos_grupo[self.modelo.endog_names].mean()
            diferencias_medias[grupo] = media_grupo

        return diferencias_medias